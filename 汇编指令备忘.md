## 第四章 寄存器与第一个程序
1. 8086CPU的工作过程:   
    (1)从CS:IP指向的内存单元读取指令,读取的指令进入指令缓冲器;   
    (2)IP=IP+所读指令的长度,从而指向下一条指令;   
    (3)执行指令.转到步骤(1),重复这个过程.
    
2. 修改CS,IP的指令:   
    (1) jmp  段基址 : 偏移地址  :同时修改 CS, IP 的值   
    (2) jmp  偏移地址   :只修改 IP 的值   
    
3. DS : 存放数据段基地址, [ N ] 表示N偏移量的内存地址中存放的数据,   
            8086CPU自动取ds中的数据作为内存单元的段基址

4. 段寄存器SS存放栈的段基址,SP存放栈顶的偏移地址,任意时刻,SS:SP指向栈顶元素.

5. 指令 push ax 执行步骤: SP=SP -one  2 , SS : SP执行当前栈顶前面的内存单元粗; 将ax 的值送进去   

6. pop ax 执行步骤 : 将SS:SP指向的内存单元中的数据送入ax中, SP=SP+2, SS:SP指向新栈顶 

7. pop 操作时,内存中的数据还在,8086CPU也不会检查栈的越界问题.

8. 一个程序从写出到执行的过程:   
    (1)编写程序 (2)对源程序进行编译链接产生可执行文件,(包括程序机器码和描述信息) 
    (3)操作系统根据可执行文件中的描述信息,将可执行文件的机器码和数据加载入内存,初始化,执行.
    
9. 汇编伪指令:由编译器来执行的指令,编译器根据伪指令来进行相关的编译工作.   
    segment , ends 的功能是定义一个段   
    assume  假设和关联   
    标号   标识了一个地址
    end 程序指明在何处结束
```
            assume  cs: codesg      #假设cs的值是codesg的地址
            codesg   segment
        s:                                        #标号,代表此处的地址
            add ax,bx

            mov ax,4c00H                #程序返回
            int 21H  
            
            codesg   ends
            end
```
## 第五章 
1. [...] 描述的是一个内存单元的内容  
    (idata)描述的是地址为idata的内存单元的内容   
    (寄存器)描述的是寄存器的内容
    
2. 指令loop 标号 ,执行过程:(1) (cx)=(cx)-1;  (2) 判断(cx)是否为0,不为0则跳至标号处执行,0则向下执行.   

3. 数据不能以字母开头,譬如要表示ffffH,需用 0ffffH来表示,在前面加多一个0   

4. dw 定义数据,开辟内存   1个字   db: 1个字节        dd: 2个字   
    dup 和db,dw,dd是配合使用的, 用来进行数据的重复,比如   
     db 300 dup (0) ;                  #300个字节   都是0   
     db 3 dup ('abc','ABC')         #18个字节,'abcABCabcABCabcABC'

5. and指令:按位与运算      or指令:按位或运算   

6. 大小写转换: 就ASCII码的二进制形式来看,除第5位外,大写字母和小写字母的其他各位都一样
    指令: mov  al,[bx]        ,and al,11011111B     mov [bx], al  #转化为大写字母,并写回
    
7. + **AX，BX，CX，DX 称作为数据寄存器：** 
    AX (Accumulator)：累加寄存器，也称之为累加器； BX (Base)：基地址寄存器；CX (Count)：计数器寄存器；DX (Data)：数据寄存器；      
    + **SP 和 BP 又称作为指针寄存器：**SP (Stack Pointer)：堆栈指针寄存器；BP (Base Pointer)：基指针寄存器；   
    + **SI 和 DI 又称作为变址寄存器：**SI (Source Index)：源变址寄存器；DI (Destination Index)：目的变址寄存器；   
    + **控制寄存器：IP (Instruction Pointer)：**指令指针寄存器；FLAG：标志寄存器；  
    + **段寄存器：CS (Code Segment)：**代码段寄存器；DS (Data Segment)：数据段寄存器；SS (Stack Segment)：堆栈段寄存器；ES (Extra Segment)：附加段寄存器；
  
8. (1)8086CPU的内存单元寻址[...]中,只能出现的寄存器是bx, si, di, bp   
    (2)在[...]中,这四个寄存器可以单独出现,或者只能以4种组合出现: bx和si, bx和di, bp和si, bp和di   
    (3)只要在[...]中使用寄存器bp,段基地址默认在SS中
    
9. 指令处理数据的长度: (1)通过寄存器来指明,  (2)通过操作符,word ptr , byte ptr   

10. div 除法指令:   
    (1)除数:在reg或内存单元中,有8位和16位   
    (2)被除数: 默认放在AX 或 AX和DX中,  DX存放高16位, AX存放低16位   
    (3)结果: 若除数是8位,则AL存放商,AH存放余数;    若除数是16位,AX商, DX余数   
 
## 第九章 转移指令
1. offset指令,用于计算标号到段基址的偏移量   例: mov ax , offset 标号

2. jmp short ptr 标号 : 8位近转移   
    jmp nert ptr 标号 : 16位近转移   
    jmp far ptr 标号: 段间远转移 CS=标号所在段基址  , IP=标号的偏移量   
    转移地址在内存中:   
    jmp word ptr 内存单元地址(段内):    从内存单元地址处存放一个字,是转移的目的偏移地址   
    例: mov ax,0123H  ; mov ds:[0],ax   ;  jmp word ptr ds:[0]   (IP=0123H)   
    jmp dword ptr 内存单元地址(段间转移) : (CS)=(内存单元地址+2),(IP)=(内存单元地址)   
    
3. jcxz 条件短转移,当(CX)==0时跳转到标号处,修改范围:-128~127   
    
4. 80 * 25 彩色字符模式显示缓冲区的结构:    
    + 内存地址空间从 0B8000H ~ 0BFFFFH 共32KB的空间,向这个空间写入数据,将立即被显示           
    + 要显示的每个字符占两个字节,分别存放ASCII字符和属性    
    + 高位字节的8位属性值意义分别如下: 闪烁, (背景色)红绿蓝, 高亮, (前景色)红绿蓝   
    
5. 